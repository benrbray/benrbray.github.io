/** @jsxImportSource hastscript */

import type { Root, Element as HastElement, ElementContent} from "hast";
import { toText } from "hast-util-to-text";
import type { VFile } from "vfile";

import { CONTINUE, SKIP, visitParents, type VisitorResult } from 'unist-util-visit-parents';
import { execSync, execFile, spawn, spawnSync } from "child_process";

////////////////////////////////////////////////////////////////////////////////

export type RehypeTypstOptions = { 
  
}

type RehypeCiteConfig = {
  
}

/**
 * Convert the user-friendly `RehypeTypstOptions` into a more explicit config
 * object.  The main difference is that any missing _options_ must be filled
 * in with a default value to create a _config_.
 *
 * This distinction between _options_ and _config_ allows for the package API
 * to change without breaking the implementation, and vice-versa.
 */
const optionsToConfig = (options: RehypeTypstOptions): RehypeCiteConfig => {
  return options;
}

export function rehypeCite(options: RehypeTypstOptions) {

  let config = optionsToConfig(options);
  return runRehypeCite(config);

}

export default rehypeCite;

////////////////////////////////////////////////////////////////////////////////


type TypstElement = {
  scope: HastElement,
  parent: HastElement|Root
}

export const visitCitations = (element: HastElement, parents: (HastElement | Root | undefined)[]): TypstElement|null => {
  // look for elements marked with "cite-inline" class
  const classes = Array.isArray(element.properties.className)
    ? element.properties.className
    : [];

  // look for data-language
  let dataLanguage = element.properties["dataLanguage"];
  if(!dataLanguage || typeof dataLanguage !== "string") { return null; }

  // code blocks generated by ` ```typst ` will have the form
  // <pre data-language="typst"><code>...</code></pre>
  if(
    element.tagName === "pre"
    && dataLanguage
  ) {
    return {
      scope: element,
      parent: parents[parents.length - 1]!
    }
  }

  return null;
}

/**
 * @param {string} mimeType
 * @param {Buffer} buffer
 * @return {Promise<string>}
 */
const bufferToDataUrl = (mimeType: string, buffer: Buffer) => {
  return `data:${mimeType};base64,${buffer.toString("base64")}`
}

const compileTypst = (
  inputFile: string
): string => {
  let r = spawnSync("typst", ["compile", "--format", "svg", "-", "-"], { input: inputFile });
  console.log(`status: ${r.status}, signal: ${r.signal}`);
  console.log(`status: ${r.status}, signal: ${r.signal}`);
  console.log(`error: ${r.error}`);
  console.log(`error: ${r.stderr}`);
  if(r.stdout) {
    return bufferToDataUrl("image/svg+xml", r.stdout);
  } else {
    throw new Error("typst returned non-zero exit code");
  }
  // return new Promise((resolve, reject) => {
  //   const child = spawn("typst", ["--format svg", "-", "-"]);
    
  //   // // collect stdout
  //   // let output: string = "";
  //   // child.stdout.on("data", (chunk) => {
  //   //   output += chunk;
  //   // })
    
  //   // // resolve promise when process finishes
  //   // child.on("close", (code) => {
  //   //   if(code !== 0) {
  //   //     throw new Error("typst finished with non-zero exit code!")
  //   //   } else {
  //   //     resolve(output);
  //   //   }
  //   // })
    
  //   // // pass typst source to stdin
  //   // child.stdin.write(inputFile);
  //   // child.stdin.end();
  // })
}

const runRehypeCite = (config: RehypeCiteConfig) => {

  const processTypst = (t: TypstElement): void => {
    console.log(`found typst! ${toText(t.scope)}`)
    
    const typstSource = toText(t.scope);
    const resultSvgBlob = compileTypst(typstSource);

    const result: HastElement = {
      type: "element",
      properties: {
        "src": resultSvgBlob
      },
      tagName: "img",
      children: []
    }

    const index = t.parent.children.indexOf(t.scope);
    t.parent.children.splice(index, 1, result);
  }

  /* ---- transform ------------------------------------- */

  console.log("\n\nrehype-typst!\n\n")

  return function(tree: Root, _file: VFile): undefined {
    // traverse the hast syntax tree, collecting all typst elements
    let typstElements: TypstElement[] = [];
    visitParents(tree, "element", (element, parents): VisitorResult => {
      // look for citation `hast` nodes produced by `remark-cite`
      const typstElement = visitCitations(element, parents);
      if(typstElement !== null) {
        typstElements.push(typstElement);
        return SKIP;
      } else {
        return CONTINUE;
      }
    });

    // render typst elements
    typstElements.forEach(t => {
      processTypst(t);
    });
  }
}